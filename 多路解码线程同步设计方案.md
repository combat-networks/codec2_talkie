# ğŸµ å¤šè·¯è§£ç çº¿ç¨‹åŒæ­¥è®¾è®¡æ–¹æ¡ˆ

## ğŸ“‹ æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†è®¾è®¡äº†Codec2 Talkieé¡¹ç›®ä¸­å¤šè·¯è§£ç çº¿ç¨‹çš„åŒæ­¥æœºåˆ¶ï¼Œç¡®ä¿å¤šè·¯éŸ³é¢‘æ•°æ®èƒ½å¤Ÿæ­£ç¡®è§£ç ã€æ··éŸ³å’Œè¾“å‡ºï¼Œä¿è¯éŸ³é¢‘è´¨é‡å’Œå®æ—¶æ€§ã€‚

## ğŸ¯ åŒæ­¥æŒ‘æˆ˜åˆ†æ

### 1. å½“å‰æ¶æ„é™åˆ¶

#### 1.1 å•çº¿ç¨‹å¤„ç†æ¨¡å¼
```java
// å½“å‰AppWorkerå•çº¿ç¨‹å¤„ç†
public void run() {
    android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_AUDIO);
    Looper.prepare();
    // æ‰€æœ‰éŸ³é¢‘å¤„ç†éƒ½åœ¨è¿™ä¸ªçº¿ç¨‹ä¸­
    Looper.loop();
}
```

**é—®é¢˜ï¼š**
- æ— æ³•å¹¶å‘å¤„ç†å¤šè·¯éŸ³é¢‘
- å•ç‚¹æ•…éšœå½±å“æ‰€æœ‰éŸ³é¢‘æµ
- ç¼ºä¹çº¿ç¨‹é—´åŒæ­¥æœºåˆ¶

#### 1.2 æ—¶åºæ§åˆ¶æœºåˆ¶
```java
// 10msé«˜é¢‘å¤„ç† + 1ç§’ç¼“å†²å»¶è¿Ÿ
private static final int PROCESS_INTERVAL_MS = 10;
private static final int GAP_TO_PLAY_MS = 1000;
```

**é—®é¢˜ï¼š**
- å›ºå®šæ—¶åºæ— æ³•é€‚åº”å¤šè·¯éŸ³é¢‘
- ç¼“å†²å»¶è¿Ÿå½±å“å®æ—¶æ€§
- ç¼ºä¹åŠ¨æ€æ—¶åºè°ƒæ•´

### 2. å¤šè·¯åŒæ­¥æŠ€æœ¯è¦æ±‚

#### 2.1 æ—¶é—´åŒæ­¥è¦æ±‚
- **é‡‡æ ·ç‡åŒæ­¥**: æ‰€æœ‰éŸ³é¢‘æµå¿…é¡»ä½¿ç”¨ç›¸åŒçš„é‡‡æ ·ç‡(8000Hz)
- **å¸§åŒæ­¥**: ç¡®ä¿éŸ³é¢‘å¸§çš„æ—¶é—´æˆ³å¯¹é½
- **æ’­æ”¾åŒæ­¥**: å¤šè·¯éŸ³é¢‘å¿…é¡»åŒæ­¥æ’­æ”¾

#### 2.2 æ•°æ®åŒæ­¥è¦æ±‚
- **é¡ºåºä¿è¯**: ç¡®ä¿éŸ³é¢‘å¸§çš„æ’­æ”¾é¡ºåº
- **å®Œæ•´æ€§ä¿è¯**: é˜²æ­¢éŸ³é¢‘å¸§ä¸¢å¤±æˆ–æŸå
- **ä¸€è‡´æ€§ä¿è¯**: å¤šè·¯éŸ³é¢‘æ•°æ®çš„ä¸€è‡´æ€§å¤„ç†

## ğŸ—ï¸ å¤šè·¯åŒæ­¥æ¶æ„è®¾è®¡

### 1. æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                å¤šè·¯è§£ç çº¿ç¨‹åŒæ­¥æ¶æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  AudioSyncManager (åŒæ­¥ç®¡ç†å™¨)                              â”‚
â”‚  â”œâ”€ TimeSyncController (æ—¶é—´åŒæ­¥æ§åˆ¶å™¨)                     â”‚
â”‚  â”œâ”€ DataSyncController (æ•°æ®åŒæ­¥æ§åˆ¶å™¨)                     â”‚
â”‚  â””â”€ OutputSyncController (è¾“å‡ºåŒæ­¥æ§åˆ¶å™¨)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  MultiChannelDecoder (å¤šè·¯è§£ç å™¨)                          â”‚
â”‚  â”œâ”€ ChannelDecoder1 (Codec2/Opus)                         â”‚
â”‚  â”œâ”€ ChannelDecoder2 (Codec2/Opus)                         â”‚
â”‚  â””â”€ ChannelDecoderN (Codec2/Opus)                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  AudioMixer (éŸ³é¢‘æ··éŸ³å™¨)                                    â”‚
â”‚  â”œâ”€ FrameBuffer (å¸§ç¼“å†²åŒº)                                 â”‚
â”‚  â”œâ”€ MixingEngine (æ··éŸ³å¼•æ“)                              â”‚
â”‚  â””â”€ OutputBuffer (è¾“å‡ºç¼“å†²åŒº)                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ ¸å¿ƒç»„ä»¶è®¾è®¡

#### 2.1 æ—¶é—´åŒæ­¥æ§åˆ¶å™¨ (TimeSyncController)

```java
public class TimeSyncController {
    private static final String TAG = "TimeSyncController";
    
    // æ—¶é—´åŒæ­¥å‚æ•°
    private static final long SYNC_INTERVAL_MS = 10;           // 10msåŒæ­¥é—´éš”
    private static final long MAX_SYNC_DRIFT_MS = 5;           // æœ€å¤§åŒæ­¥æ¼‚ç§»5ms
    private static final long FRAME_DURATION_MS = 20;           // éŸ³é¢‘å¸§æŒç»­æ—¶é—´20ms
    
    // åŒæ­¥çŠ¶æ€
    private volatile long masterTimestamp = 0;                 // ä¸»æ—¶é—´æˆ³
    private volatile boolean isSyncActive = false;             // åŒæ­¥æ¿€æ´»çŠ¶æ€
    private final Object syncLock = new Object();              // åŒæ­¥é”
    
    // å¤šè·¯éŸ³é¢‘æ—¶é—´æˆ³
    private final Map<String, Long> channelTimestamps = new ConcurrentHashMap<>();
    private final Map<String, Long> channelDrifts = new ConcurrentHashMap<>();
    
    /**
     * åˆå§‹åŒ–æ—¶é—´åŒæ­¥
     */
    public void initializeSync() {
        synchronized (syncLock) {
            masterTimestamp = System.currentTimeMillis();
            isSyncActive = true;
            Log.i(TAG, "Time sync initialized with master timestamp: " + masterTimestamp);
        }
    }
    
    /**
     * æ³¨å†ŒéŸ³é¢‘é€šé“æ—¶é—´æˆ³
     */
    public void registerChannelTimestamp(String channelId, long timestamp) {
        synchronized (syncLock) {
            if (!isSyncActive) {
                Log.w(TAG, "Sync not active, ignoring timestamp for channel: " + channelId);
                return;
            }
            
            long currentTime = System.currentTimeMillis();
            long drift = Math.abs(currentTime - timestamp);
            
            channelTimestamps.put(channelId, timestamp);
            channelDrifts.put(channelId, drift);
            
            // æ£€æŸ¥åŒæ­¥æ¼‚ç§»
            if (drift > MAX_SYNC_DRIFT_MS) {
                Log.w(TAG, "Channel " + channelId + " has sync drift: " + drift + "ms");
                adjustChannelSync(channelId, drift);
            }
        }
    }
    
    /**
     * è°ƒæ•´é€šé“åŒæ­¥
     */
    private void adjustChannelSync(String channelId, long drift) {
        // å®ç°åŒæ­¥è°ƒæ•´é€»è¾‘
        Log.i(TAG, "Adjusting sync for channel " + channelId + " by " + drift + "ms");
    }
    
    /**
     * è·å–åŒæ­¥åçš„æ—¶é—´æˆ³
     */
    public long getSyncedTimestamp(String channelId) {
        synchronized (syncLock) {
            Long channelTimestamp = channelTimestamps.get(channelId);
            if (channelTimestamp == null) {
                return masterTimestamp;
            }
            
            Long drift = channelDrifts.get(channelId);
            if (drift != null && drift > MAX_SYNC_DRIFT_MS) {
                // åº”ç”¨åŒæ­¥è°ƒæ•´
                return channelTimestamp + drift;
            }
            
            return channelTimestamp;
        }
    }
    
    /**
     * æ£€æŸ¥æ‰€æœ‰é€šé“æ˜¯å¦åŒæ­¥
     */
    public boolean areAllChannelsSynced() {
        synchronized (syncLock) {
            if (channelTimestamps.isEmpty()) {
                return false;
            }
            
            long maxDrift = channelDrifts.values().stream()
                .mapToLong(Long::longValue)
                .max()
                .orElse(0);
            
            return maxDrift <= MAX_SYNC_DRIFT_MS;
        }
    }
}
```

#### 2.2 æ•°æ®åŒæ­¥æ§åˆ¶å™¨ (DataSyncController)

```java
public class DataSyncController {
    private static final String TAG = "DataSyncController";
    
    // æ•°æ®åŒæ­¥å‚æ•°
    private static final int MAX_BUFFER_SIZE = 1024;            // æœ€å¤§ç¼“å†²åŒºå¤§å°
    private static final int SYNC_TIMEOUT_MS = 100;            // åŒæ­¥è¶…æ—¶100ms
    private static final int MAX_RETRY_COUNT = 3;               // æœ€å¤§é‡è¯•æ¬¡æ•°
    
    // åŒæ­¥çŠ¶æ€
    private volatile boolean isDataSyncActive = false;          // æ•°æ®åŒæ­¥æ¿€æ´»çŠ¶æ€
    private final Object dataSyncLock = new Object();          // æ•°æ®åŒæ­¥é”
    
    // å¤šè·¯éŸ³é¢‘æ•°æ®ç¼“å†²åŒº
    private final Map<String, BlockingQueue<AudioFrame>> channelBuffers = new ConcurrentHashMap<>();
    private final Map<String, Long> channelLastDataTime = new ConcurrentHashMap<>();
    
    /**
     * åˆå§‹åŒ–æ•°æ®åŒæ­¥
     */
    public void initializeDataSync() {
        synchronized (dataSyncLock) {
            isDataSyncActive = true;
            Log.i(TAG, "Data sync initialized");
        }
    }
    
    /**
     * æ³¨å†ŒéŸ³é¢‘é€šé“æ•°æ®ç¼“å†²åŒº
     */
    public void registerChannelBuffer(String channelId) {
        synchronized (dataSyncLock) {
            channelBuffers.put(channelId, new LinkedBlockingQueue<>(MAX_BUFFER_SIZE));
            channelLastDataTime.put(channelId, 0L);
            Log.i(TAG, "Registered buffer for channel: " + channelId);
        }
    }
    
    /**
     * æ·»åŠ éŸ³é¢‘å¸§åˆ°ç¼“å†²åŒº
     */
    public boolean addAudioFrame(String channelId, AudioFrame frame) {
        BlockingQueue<AudioFrame> buffer = channelBuffers.get(channelId);
        if (buffer == null) {
            Log.e(TAG, "No buffer found for channel: " + channelId);
            return false;
        }
        
        try {
            boolean added = buffer.offer(frame, SYNC_TIMEOUT_MS, TimeUnit.MILLISECONDS);
            if (added) {
                channelLastDataTime.put(channelId, System.currentTimeMillis());
                Log.d(TAG, "Added frame to channel " + channelId + " buffer");
            } else {
                Log.w(TAG, "Failed to add frame to channel " + channelId + " buffer (timeout)");
            }
            return added;
        } catch (InterruptedException e) {
            Log.e(TAG, "Interrupted while adding frame to channel " + channelId, e);
            Thread.currentThread().interrupt();
            return false;
        }
    }
    
    /**
     * è·å–åŒæ­¥çš„éŸ³é¢‘å¸§
     */
    public List<AudioFrame> getSyncedFrames() {
        List<AudioFrame> syncedFrames = new ArrayList<>();
        
        synchronized (dataSyncLock) {
            if (!isDataSyncActive) {
                return syncedFrames;
            }
            
            // æ£€æŸ¥æ‰€æœ‰é€šé“æ˜¯å¦æœ‰æ•°æ®
            boolean allChannelsHaveData = true;
            for (String channelId : channelBuffers.keySet()) {
                BlockingQueue<AudioFrame> buffer = channelBuffers.get(channelId);
                if (buffer.isEmpty()) {
                    allChannelsHaveData = false;
                    break;
                }
            }
            
            if (allChannelsHaveData) {
                // ä»æ‰€æœ‰é€šé“è·å–åŒæ­¥å¸§
                for (String channelId : channelBuffers.keySet()) {
                    BlockingQueue<AudioFrame> buffer = channelBuffers.get(channelId);
                    AudioFrame frame = buffer.poll();
                    if (frame != null) {
                        syncedFrames.add(frame);
                        Log.d(TAG, "Retrieved synced frame from channel: " + channelId);
                    }
                }
            }
        }
        
        return syncedFrames;
    }
    
    /**
     * æ£€æŸ¥æ•°æ®åŒæ­¥çŠ¶æ€
     */
    public boolean isDataSynced() {
        synchronized (dataSyncLock) {
            if (channelBuffers.isEmpty()) {
                return false;
            }
            
            long currentTime = System.currentTimeMillis();
            for (String channelId : channelLastDataTime.keySet()) {
                Long lastDataTime = channelLastDataTime.get(channelId);
                if (lastDataTime == null || (currentTime - lastDataTime) > SYNC_TIMEOUT_MS) {
                    Log.w(TAG, "Channel " + channelId + " data sync timeout");
                    return false;
                }
            }
            
            return true;
        }
    }
}
```

#### 2.3 è¾“å‡ºåŒæ­¥æ§åˆ¶å™¨ (OutputSyncController)

```java
public class OutputSyncController {
    private static final String TAG = "OutputSyncController";
    
    // è¾“å‡ºåŒæ­¥å‚æ•°
    private static final int OUTPUT_BUFFER_SIZE = 2048;         // è¾“å‡ºç¼“å†²åŒºå¤§å°
    private static final int MIXING_INTERVAL_MS = 10;           // æ··éŸ³é—´éš”10ms
    private static final int MAX_OUTPUT_LATENCY_MS = 50;       // æœ€å¤§è¾“å‡ºå»¶è¿Ÿ50ms
    
    // åŒæ­¥çŠ¶æ€
    private volatile boolean isOutputSyncActive = false;        // è¾“å‡ºåŒæ­¥æ¿€æ´»çŠ¶æ€
    private final Object outputSyncLock = new Object();       // è¾“å‡ºåŒæ­¥é”
    
    // æ··éŸ³è¾“å‡ºç¼“å†²åŒº
    private final AudioMixer audioMixer;
    private final AudioTrack outputAudioTrack;
    private final Timer outputTimer;
    
    public OutputSyncController(AudioMixer mixer, AudioTrack audioTrack) {
        this.audioMixer = mixer;
        this.outputAudioTrack = audioTrack;
        this.outputTimer = new Timer("OutputSyncTimer");
    }
    
    /**
     * åˆå§‹åŒ–è¾“å‡ºåŒæ­¥
     */
    public void initializeOutputSync() {
        synchronized (outputSyncLock) {
            isOutputSyncActive = true;
            
            // å¯åŠ¨è¾“å‡ºå®šæ—¶å™¨
            outputTimer.scheduleAtFixedRate(new TimerTask() {
                @Override
                public void run() {
                    processOutputSync();
                }
            }, 0, MIXING_INTERVAL_MS);
            
            Log.i(TAG, "Output sync initialized");
        }
    }
    
    /**
     * å¤„ç†è¾“å‡ºåŒæ­¥
     */
    private void processOutputSync() {
        if (!isOutputSyncActive) {
            return;
        }
        
        try {
            // è·å–æ··éŸ³åçš„éŸ³é¢‘æ•°æ®
            short[] mixedAudio = audioMixer.getMixedAudio();
            if (mixedAudio != null && mixedAudio.length > 0) {
                // å†™å…¥AudioTrack
                int bytesWritten = outputAudioTrack.write(mixedAudio, 0, mixedAudio.length);
                if (bytesWritten > 0) {
                    Log.d(TAG, "Wrote " + bytesWritten + " bytes to AudioTrack");
                } else {
                    Log.w(TAG, "Failed to write audio to AudioTrack");
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "Error in output sync processing", e);
        }
    }
    
    /**
     * åœæ­¢è¾“å‡ºåŒæ­¥
     */
    public void stopOutputSync() {
        synchronized (outputSyncLock) {
            isOutputSyncActive = false;
            outputTimer.cancel();
            Log.i(TAG, "Output sync stopped");
        }
    }
}
```

### 3. å¤šè·¯è§£ç å™¨åŒæ­¥å®ç°

#### 3.1 åŒæ­¥è§£ç å™¨åŸºç±»

```java
public abstract class SyncChannelDecoder {
    private static final String TAG = "SyncChannelDecoder";
    
    protected final String channelId;
    protected final TimeSyncController timeSyncController;
    protected final DataSyncController dataSyncController;
    protected final OutputSyncController outputSyncController;
    
    // è§£ç å™¨çŠ¶æ€
    protected volatile boolean isDecoding = false;
    protected volatile long lastDecodeTime = 0;
    protected final Object decodeLock = new Object();
    
    public SyncChannelDecoder(String channelId, 
                             TimeSyncController timeSync,
                             DataSyncController dataSync,
                             OutputSyncController outputSync) {
        this.channelId = channelId;
        this.timeSyncController = timeSync;
        this.dataSyncController = dataSync;
        this.outputSyncController = outputSync;
    }
    
    /**
     * åŒæ­¥è§£ç éŸ³é¢‘å¸§
     */
    public void syncDecodeAudioFrame(byte[] encodedFrame) {
        synchronized (decodeLock) {
            if (!isDecoding) {
                Log.w(TAG, "Decoder not active for channel: " + channelId);
                return;
            }
            
            try {
                // è·å–å½“å‰æ—¶é—´æˆ³
                long currentTimestamp = System.currentTimeMillis();
                
                // æ³¨å†Œæ—¶é—´æˆ³åˆ°åŒæ­¥æ§åˆ¶å™¨
                timeSyncController.registerChannelTimestamp(channelId, currentTimestamp);
                
                // æ‰§è¡Œè§£ç 
                short[] decodedAudio = performDecode(encodedFrame);
                
                if (decodedAudio != null && decodedAudio.length > 0) {
                    // åˆ›å»ºéŸ³é¢‘å¸§
                    AudioFrame audioFrame = new AudioFrame(
                        channelId,
                        decodedAudio,
                        currentTimestamp,
                        decodedAudio.length
                    );
                    
                    // æ·»åŠ åˆ°æ•°æ®åŒæ­¥æ§åˆ¶å™¨
                    boolean added = dataSyncController.addAudioFrame(channelId, audioFrame);
                    if (added) {
                        lastDecodeTime = currentTimestamp;
                        Log.d(TAG, "Successfully decoded and synced frame for channel: " + channelId);
                    } else {
                        Log.w(TAG, "Failed to add decoded frame to sync controller for channel: " + channelId);
                    }
                } else {
                    Log.w(TAG, "Decode returned null or empty audio for channel: " + channelId);
                }
                
            } catch (Exception e) {
                Log.e(TAG, "Error in sync decode for channel: " + channelId, e);
            }
        }
    }
    
    /**
     * æŠ½è±¡è§£ç æ–¹æ³•ï¼Œç”±å­ç±»å®ç°
     */
    protected abstract short[] performDecode(byte[] encodedFrame);
    
    /**
     * å¯åŠ¨è§£ç å™¨
     */
    public void startDecoding() {
        synchronized (decodeLock) {
            isDecoding = true;
            Log.i(TAG, "Started decoding for channel: " + channelId);
        }
    }
    
    /**
     * åœæ­¢è§£ç å™¨
     */
    public void stopDecoding() {
        synchronized (decodeLock) {
            isDecoding = false;
            Log.i(TAG, "Stopped decoding for channel: " + channelId);
        }
    }
}
```

#### 3.2 Codec2åŒæ­¥è§£ç å™¨

```java
public class SyncCodec2Decoder extends SyncChannelDecoder {
    private static final String TAG = "SyncCodec2Decoder";
    
    private long codec2Context;
    private short[] decodeBuffer;
    
    public SyncCodec2Decoder(String channelId,
                            TimeSyncController timeSync,
                            DataSyncController dataSync,
                            OutputSyncController outputSync) {
        super(channelId, timeSync, dataSync, outputSync);
        
        // åˆå§‹åŒ–Codec2è§£ç å™¨
        codec2Context = Codec2.create(Codec2.MODE_3200);
        decodeBuffer = new short[160]; // 20ms @ 8kHz
        
        Log.i(TAG, "Initialized Codec2 decoder for channel: " + channelId);
    }
    
    @Override
    protected short[] performDecode(byte[] encodedFrame) {
        try {
            // è°ƒç”¨Codec2è§£ç 
            long result = Codec2.decode(codec2Context, decodeBuffer, encodedFrame);
            
            if (result > 0) {
                // å¤åˆ¶è§£ç ç»“æœ
                short[] decodedAudio = new short[(int)result];
                System.arraycopy(decodeBuffer, 0, decodedAudio, 0, (int)result);
                
                Log.d(TAG, "Codec2 decoded " + result + " samples for channel: " + channelId);
                return decodedAudio;
            } else {
                Log.w(TAG, "Codec2 decode returned " + result + " for channel: " + channelId);
                return null;
            }
        } catch (Exception e) {
            Log.e(TAG, "Error in Codec2 decode for channel: " + channelId, e);
            return null;
        }
    }
    
    /**
     * æ¸…ç†èµ„æº
     */
    public void cleanup() {
        if (codec2Context != 0) {
            Codec2.destroy(codec2Context);
            codec2Context = 0;
        }
        Log.i(TAG, "Cleaned up Codec2 decoder for channel: " + channelId);
    }
}
```

#### 3.3 OpusåŒæ­¥è§£ç å™¨

```java
public class SyncOpusDecoder extends SyncChannelDecoder {
    private static final String TAG = "SyncOpusDecoder";
    
    private long opusContext;
    private short[] decodeBuffer;
    private final int maxSamples;
    
    public SyncOpusDecoder(String channelId,
                          TimeSyncController timeSync,
                          DataSyncController dataSync,
                          OutputSyncController outputSync) {
        super(channelId, timeSync, dataSync, outputSync);
        
        // åˆå§‹åŒ–Opusè§£ç å™¨
        opusContext = Opus.create(8000, 1, Opus.OPUS_APPLICATION_VOIP, 32000, 5);
        maxSamples = 160; // 20ms @ 8kHz
        decodeBuffer = new short[maxSamples];
        
        Log.i(TAG, "Initialized Opus decoder for channel: " + channelId);
    }
    
    @Override
    protected short[] performDecode(byte[] encodedFrame) {
        try {
            // è°ƒç”¨Opusè§£ç 
            int decodedSamples = Opus.decode(opusContext, encodedFrame, decodeBuffer, maxSamples);
            
            if (decodedSamples > 0) {
                // å¤åˆ¶è§£ç ç»“æœ
                short[] decodedAudio = new short[decodedSamples];
                System.arraycopy(decodeBuffer, 0, decodedAudio, 0, decodedSamples);
                
                Log.d(TAG, "Opus decoded " + decodedSamples + " samples for channel: " + channelId);
                return decodedAudio;
            } else {
                Log.w(TAG, "Opus decode returned " + decodedSamples + " for channel: " + channelId);
                return null;
            }
        } catch (Exception e) {
            Log.e(TAG, "Error in Opus decode for channel: " + channelId, e);
            return null;
        }
    }
    
    /**
     * æ¸…ç†èµ„æº
     */
    public void cleanup() {
        if (opusContext != 0) {
            Opus.destroy(opusContext);
            opusContext = 0;
        }
        Log.i(TAG, "Cleaned up Opus decoder for channel: " + channelId);
    }
}
```

### 4. éŸ³é¢‘å¸§æ•°æ®ç»“æ„

```java
public class AudioFrame {
    private final String channelId;           // é€šé“ID
    private final short[] audioData;          // éŸ³é¢‘æ•°æ®
    private final long timestamp;             // æ—¶é—´æˆ³
    private final int sampleCount;            // é‡‡æ ·æ•°
    private final long sequenceNumber;        // åºåˆ—å·
    
    private static long globalSequenceNumber = 0;
    
    public AudioFrame(String channelId, short[] audioData, long timestamp, int sampleCount) {
        this.channelId = channelId;
        this.audioData = audioData.clone(); // æ·±æ‹·è´
        this.timestamp = timestamp;
        this.sampleCount = sampleCount;
        this.sequenceNumber = ++globalSequenceNumber;
    }
    
    // Getters
    public String getChannelId() { return channelId; }
    public short[] getAudioData() { return audioData.clone(); }
    public long getTimestamp() { return timestamp; }
    public int getSampleCount() { return sampleCount; }
    public long getSequenceNumber() { return sequenceNumber; }
    
    @Override
    public String toString() {
        return String.format("AudioFrame[channel=%s, samples=%d, timestamp=%d, seq=%d]",
                channelId, sampleCount, timestamp, sequenceNumber);
    }
}
```

## ğŸ”„ åŒæ­¥æµç¨‹æ—¶åºå›¾

```
æ—¶é—´è½´: 0ms    10ms   20ms   30ms   40ms   50ms
        |       |      |      |      |      |
é€šé“1:  [å¸§1]   [å¸§2]  [å¸§3]  [å¸§4]  [å¸§5]  [å¸§6]
        |       |      |      |      |      |
é€šé“2:  [å¸§1]   [å¸§2]  [å¸§3]  [å¸§4]  [å¸§5]  [å¸§6]
        |       |      |      |      |      |
æ—¶é—´åŒæ­¥: æ³¨å†Œ   æ³¨å†Œ   æ³¨å†Œ   æ³¨å†Œ   æ³¨å†Œ   æ³¨å†Œ
        |       |      |      |      |      |
æ•°æ®åŒæ­¥: ç¼“å†²   ç¼“å†²   ç¼“å†²   ç¼“å†²   ç¼“å†²   ç¼“å†²
        |       |      |      |      |      |
æ··éŸ³è¾“å‡º: ç­‰å¾…   ç­‰å¾…   æ··éŸ³   æ··éŸ³   æ··éŸ³   æ··éŸ³
        |       |      |      |      |      |
AudioTrack: é™éŸ³  é™éŸ³   æ’­æ”¾   æ’­æ”¾   æ’­æ”¾   æ’­æ”¾
```

## âš¡ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å†…å­˜ç®¡ç†ä¼˜åŒ–

```java
public class AudioBufferPool {
    private static final int POOL_SIZE = 10;
    private final Queue<short[]> bufferPool = new ConcurrentLinkedQueue<>();
    private final Queue<AudioFrame> framePool = new ConcurrentLinkedQueue<>();
    
    public AudioBufferPool() {
        // é¢„åˆ†é…ç¼“å†²åŒº
        for (int i = 0; i < POOL_SIZE; i++) {
            bufferPool.offer(new short[160]); // 20ms @ 8kHz
            framePool.offer(new AudioFrame("", new short[0], 0, 0));
        }
    }
    
    public short[] getBuffer() {
        short[] buffer = bufferPool.poll();
        return buffer != null ? buffer : new short[160];
    }
    
    public void returnBuffer(short[] buffer) {
        if (buffer.length == 160 && bufferPool.size() < POOL_SIZE) {
            Arrays.fill(buffer, (short)0); // æ¸…é›¶
            bufferPool.offer(buffer);
        }
    }
}
```

### 2. çº¿ç¨‹ä¼˜å…ˆçº§ä¼˜åŒ–

```java
public class SyncThreadManager {
    private static final int AUDIO_THREAD_PRIORITY = Process.THREAD_PRIORITY_URGENT_AUDIO;
    private static final int HIGH_THREAD_PRIORITY = Process.THREAD_PRIORITY_URGENT_DISPLAY;
    
    public static void setAudioThreadPriority(Thread thread) {
        android.os.Process.setThreadPriority(AUDIO_THREAD_PRIORITY);
    }
    
    public static void setHighThreadPriority(Thread thread) {
        android.os.Process.setThreadPriority(HIGH_THREAD_PRIORITY);
    }
}
```

### 3. åŒæ­¥æ€§èƒ½ç›‘æ§

```java
public class SyncPerformanceMonitor {
    private final Map<String, Long> channelLatencies = new ConcurrentHashMap<>();
    private final Map<String, Integer> channelDropCounts = new ConcurrentHashMap<>();
    
    public void recordChannelLatency(String channelId, long latency) {
        channelLatencies.put(channelId, latency);
    }
    
    public void recordChannelDrop(String channelId) {
        channelDropCounts.merge(channelId, 1, Integer::sum);
    }
    
    public void logPerformanceStats() {
        Log.i("SyncPerformance", "Channel latencies: " + channelLatencies);
        Log.i("SyncPerformance", "Channel drops: " + channelDropCounts);
    }
}
```

## ğŸ›¡ï¸ é”™è¯¯å¤„ç†å’Œæ¢å¤

### 1. åŒæ­¥é”™è¯¯å¤„ç†

```java
public class SyncErrorHandler {
    private static final int MAX_SYNC_ERRORS = 5;
    private final Map<String, Integer> channelErrorCounts = new ConcurrentHashMap<>();
    
    public boolean handleSyncError(String channelId, Exception error) {
        int errorCount = channelErrorCounts.merge(channelId, 1, Integer::sum);
        
        if (errorCount > MAX_SYNC_ERRORS) {
            Log.e("SyncError", "Too many sync errors for channel " + channelId + ", disabling");
            return false; // ç¦ç”¨é€šé“
        }
        
        Log.w("SyncError", "Sync error for channel " + channelId + ": " + error.getMessage());
        return true; // ç»§ç»­å¤„ç†
    }
    
    public void resetChannelErrors(String channelId) {
        channelErrorCounts.remove(channelId);
    }
}
```

### 2. è‡ªåŠ¨æ¢å¤æœºåˆ¶

```java
public class SyncRecoveryManager {
    private static final long RECOVERY_CHECK_INTERVAL_MS = 1000;
    private final Timer recoveryTimer;
    
    public SyncRecoveryManager() {
        this.recoveryTimer = new Timer("SyncRecoveryTimer");
    }
    
    public void startRecoveryMonitoring() {
        recoveryTimer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                checkAndRecoverSync();
            }
        }, RECOVERY_CHECK_INTERVAL_MS, RECOVERY_CHECK_INTERVAL_MS);
    }
    
    private void checkAndRecoverSync() {
        // æ£€æŸ¥åŒæ­¥çŠ¶æ€å¹¶æ‰§è¡Œæ¢å¤æ“ä½œ
        Log.d("SyncRecovery", "Checking sync recovery status");
    }
}
```

## ğŸ“Š æ€»ç»“

æœ¬è®¾è®¡æ–¹æ¡ˆæä¾›äº†å®Œæ•´çš„å¤šè·¯è§£ç çº¿ç¨‹åŒæ­¥è§£å†³æ–¹æ¡ˆï¼š

1. **æ—¶é—´åŒæ­¥**: é€šè¿‡TimeSyncControllerç¡®ä¿å¤šè·¯éŸ³é¢‘çš„æ—¶é—´æˆ³å¯¹é½
2. **æ•°æ®åŒæ­¥**: é€šè¿‡DataSyncControllerä¿è¯éŸ³é¢‘å¸§çš„å®Œæ•´æ€§å’Œé¡ºåº
3. **è¾“å‡ºåŒæ­¥**: é€šè¿‡OutputSyncControllerç¡®ä¿æ··éŸ³è¾“å‡ºçš„å®æ—¶æ€§
4. **æ€§èƒ½ä¼˜åŒ–**: å†…å­˜æ± ã€çº¿ç¨‹ä¼˜å…ˆçº§ã€æ€§èƒ½ç›‘æ§ç­‰ä¼˜åŒ–æªæ–½
5. **é”™è¯¯å¤„ç†**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œè‡ªåŠ¨æ¢å¤æœºåˆ¶

è¯¥æ–¹æ¡ˆèƒ½å¤Ÿç¡®ä¿å¤šè·¯è§£ç çº¿ç¨‹çš„åŒæ­¥ï¼Œä¿è¯éŸ³é¢‘è´¨é‡å’Œå®æ—¶æ€§ï¼Œä¸ºCodec2 Talkieé¡¹ç›®æä¾›å¯é çš„å¤šè·¯éŸ³é¢‘å¤„ç†èƒ½åŠ›ã€‚
