# 🎵 音频数据包格式详细分析

## 1. 音频数据包层次结构

```
PCM 音频数据 (16位采样)
    ↓
音频编码层 (Codec2/Opus)
    ↓
压缩音频帧
    ↓
AX.25 音频数据包 (PID=0xF1)
    ↓
HDLC 帧同步
    ↓
KISS 协议传输
```

## 2. Codec2 音频数据包格式

### 2.1 Codec2 模式定义
```java
// arrays.xml:21-30
<string-array name="codec2_modes">
    <item>MODE_450=10</item>      // 450 bps
    <item>MODE_700C=8</item>      // 700 bps
    <item>MODE_1200=5</item>      // 1200 bps
    <item>MODE_1300=4</item>      // 1300 bps
    <item>MODE_1400=3</item>      // 1400 bps
    <item>MODE_1600=2</item>      // 1600 bps
    <item>MODE_2400=1</item>      // 2400 bps
    <item>MODE_3200=0</item>      // 3200 bps
</string-array>
```

### 2.2 Codec2 帧结构
```java
// AudioCodec2.java:183-194
private void constructCodec2(int codecMode) {
    _codec2Con = Codec2.create(codecMode);
    
    _audioBufferSize = Codec2.getSamplesPerFrame(_codec2Con);  // PCM样本数
    int codec2FrameSize = Codec2.getBitsSize(_codec2Con);      // 编码后字节数
    
    _recordAudioEncodedBuffer = new char[codec2FrameSize];    // 编码缓冲区
    _playbackAudioBuffer = new short[_audioBufferSize];       // 播放缓冲区
}
```

### 2.3 Codec2 编码过程
```java
// AudioCodec2.java:61-72
public void sendPcmAudio(String src, String dst, short[] pcmFrame) throws IOException {
    _parentProtocolCallback.onTransmitPcmAudio(src, dst, pcmFrame);
    
    // Codec2 编码
    Codec2.encode(_codec2Con, pcmFrame, _recordAudioEncodedBuffer);
    
    // 转换为字节数组
    byte[] frame = new byte[_recordAudioEncodedBuffer.length];
    for (int i = 0; i < _recordAudioEncodedBuffer.length; i++) {
        frame[i] = (byte)_recordAudioEncodedBuffer[i];
    }
    _childProtocol.sendCompressedAudio(src, dst, frame);
}
```

### 2.4 Codec2 解码过程
```java
// AudioCodec2.java:96-99
protected void onReceiveCompressedAudio(String src, String dst, byte[] audioFrame) {
    Codec2.decode(_codec2Con, _playbackAudioBuffer, audioFrame);
    _parentProtocolCallback.onReceivePcmAudio(src, dst, _playbackAudioBuffer);
}
```

## 3. Opus 音频数据包格式

### 3.1 Opus 配置参数
```java
// AudioOpus.java:44-59
SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(context);
int bitRate = Integer.parseInt(sharedPreferences.getString(PreferenceKeys.OPUS_BIT_RATE, "3200"));
int complexity = Integer.parseInt(sharedPreferences.getString(PreferenceKeys.OPUS_COMPLEXITY, "5"));
float pcmFrameDuration = Float.parseFloat(sharedPreferences.getString(PreferenceKeys.OPUS_FRAME_SIZE, "40"));

_pcmFrameSize = (int)(SAMPLE_RATE / 1000 * pcmFrameDuration);  // 8kHz采样率
_audioBufferSize = 10*_pcmFrameSize;

_opusCon = Opus.create(SAMPLE_RATE, 1, Opus.OPUS_APPLICATION_VOIP, bitRate, complexity);
```

### 3.2 Opus 帧大小选项
```java
// arrays.xml:32-42
<string-array name="opus_frame_size">
    <item>2.5</item>    // 2.5ms 帧
    <item>5</item>      // 5ms 帧
    <item>10</item>     // 10ms 帧
    <item>20</item>     // 20ms 帧
    <item>40</item>     // 40ms 帧
    <item>60</item>     // 60ms 帧
    <item>80</item>     // 80ms 帧
    <item>100</item>    // 100ms 帧
    <item>120</item>    // 120ms 帧
</string-array>
```

### 3.3 Opus 编码过程
```java
// AudioOpus.java:78-94
public void sendPcmAudio(String src, String dst, short[] pcmFrame) throws IOException {
    _parentProtocolCallback.onTransmitPcmAudio(src, dst, pcmFrame);
    
    // Opus 编码
    int encodedBytesCnt = Opus.encode(_opusCon, pcmFrame, _pcmFrameSize, _recordAudioEncodedBuffer);
    
    if (encodedBytesCnt > 0) {
        byte[] frame = new byte[encodedBytesCnt];
        System.arraycopy(_recordAudioEncodedBuffer, 0, frame, 0, encodedBytesCnt);
        Log.v(TAG, "pcm count: " + pcmFrame.length + ", encoded bytes count: " + encodedBytesCnt);
        _childProtocol.sendCompressedAudio(src, dst, frame);
    } else {
        Log.e(TAG, "Encode error: " + encodedBytesCnt);
        _parentProtocolCallback.onProtocolTxError();
    }
}
```

### 3.4 Opus 解码过程
```java
// AudioOpus.java:118-133
protected void onReceiveCompressedAudio(String src, String dst, byte[] audioEncodedFrame) {
    int decodedSamplesCnt = Opus.decode(_opusCon, audioEncodedFrame, _playbackAudioBuffer, _audioBufferSize);
    Log.v(TAG, "encoded frame size: " + audioEncodedFrame.length + ", decoded samples count:" + decodedSamplesCnt);
    
    if (decodedSamplesCnt > 0) {
        short[] decodedSamples = new short[decodedSamplesCnt];
        System.arraycopy(_playbackAudioBuffer, 0, decodedSamples, 0, decodedSamplesCnt);
        _parentProtocolCallback.onReceivePcmAudio(src, dst, decodedSamples);
    } else {
        Log.e(TAG, "Decode error: " + decodedSamplesCnt);
        _parentProtocolCallback.onProtocolRxError();
    }
}
```

## 4. 音频帧聚合器

### 4.1 帧聚合逻辑
```java
// AudioCodec2FrameAggregator.java:70-79
public void sendCompressedAudio(String src, String dst, byte[] frame) throws IOException {
    if (_outputBufferPos + frame.length > _outputBufferSize) {
        // 缓冲区满，发送聚合帧
        _childProtocol.sendCompressedAudio(src, dst, Arrays.copyOf(_outputBuffer, _outputBufferPos));
        _outputBufferPos = 0;
    }
    _lastSrc = src;
    _lastDst = dst;
    System.arraycopy(frame, 0, _outputBuffer, _outputBufferPos, frame.length);
    _outputBufferPos += frame.length;
}
```

### 4.2 帧分离逻辑
```java
// AudioCodec2FrameAggregator.java:113-127
protected void onReceiveCompressedAudio(String src, String dst, byte[] audioFrames) {
    if (audioFrames.length % _codec2FrameSize != 0) {
        Log.e(TAG, "Ignoring audio frame of wrong size: " + audioFrames.length);
        _parentProtocolCallback.onProtocolRxError();
    } else {
        // 按帧大小分离音频帧
        byte[] audioFrame = new byte[_codec2FrameSize];
        for (int i = 0; i < audioFrames.length; i += _codec2FrameSize) {
            for (int j = 0; j < _codec2FrameSize && (j + i) < audioFrames.length; j++) {
                audioFrame[j] = audioFrames[i + j];
            }
            _parentProtocolCallback.onReceiveCompressedAudio(src, dst, audioFrame);
        }
    }
}
```

## 5. AX.25 音频数据包格式

### 5.1 音频数据包标识
```java
// AX25Packet.java:26-28
private final byte AX25CTRL_UI = (byte)0x03;        // UI 帧
private final byte AX25PID_NO_LAYER3 = (byte)0xf0;   // 非音频数据
private final byte AX25PID_AUDIO = (byte)0xf1;       // 音频数据
```

### 5.2 音频数据包结构
```
| 目标地址 | 源地址 | 中继路径 | 控制 | PID | 音频数据 |
| 7字节   | 7字节  | 7字节×N | 0x03 |0xF1 | 变长     |
```

### 5.3 音频数据包识别
```java
// AX25Packet.java:82-90
byte ax25Pid = buffer.get();
if (ax25Pid == AX25PID_AUDIO) {
    isAudio = true;                    // 标记为音频数据
} else if (ax25Pid == AX25PID_NO_LAYER3) {
    isAudio = false;                   // 标记为非音频数据
} else {
    return;                           // 无效PID
}
```

## 6. 音频数据包处理流程

### 6.1 发送流程
```
PCM 音频输入 (16位采样)
    ↓
音频编码 (Codec2/Opus)
    ↓
压缩音频帧
    ↓
帧聚合 (可选)
    ↓
AX.25 音频包 (PID=0xF1)
    ↓
HDLC 帧同步
    ↓
KISS 协议传输
```

### 6.2 接收流程
```
KISS 协议接收
    ↓
HDLC 帧同步
    ↓
AX.25 包解析 (PID=0xF1)
    ↓
帧分离 (可选)
    ↓
音频解码 (Codec2/Opus)
    ↓
PCM 音频输出
```

## 7. 音频数据包技术参数

### 7.1 Codec2 技术参数
```java
// 不同模式的帧大小和比特率
MODE_3200: 8字节/帧,  20ms, 3200 bps
MODE_2400: 6字节/帧,  20ms, 2400 bps  
MODE_1600: 4字节/帧,  20ms, 1600 bps
MODE_1400: 3.5字节/帧, 20ms, 1400 bps
MODE_1300: 3.25字节/帧, 20ms, 1300 bps
MODE_1200: 3字节/帧,  20ms, 1200 bps
MODE_700C: 1.75字节/帧, 20ms, 700 bps
MODE_450:  1.125字节/帧, 20ms, 450 bps
```

### 7.2 Opus 技术参数
```java
// 可配置参数
采样率: 8000 Hz
声道数: 1 (单声道)
应用类型: VOIP
比特率: 2400-512000 bps
复杂度: 0-10
帧长度: 2.5-120ms
```

## 8. 音频数据包缓冲区管理

### 8.1 发送缓冲区
```java
// AudioCodec2FrameAggregator.java:26-28
private int _outputBufferSize;        // 最大聚合帧大小
private int _outputBufferPos;         // 当前缓冲区位置
private byte[] _outputBuffer;        // 输出缓冲区
```

### 8.2 接收缓冲区
```java
// AudioCodec2.java:23-24
private char[] _recordAudioEncodedBuffer;  // 编码缓冲区
private short[] _playbackAudioBuffer;     // 播放缓冲区
```

## 9. 音频数据包错误处理

### 9.1 编码错误
```java
// AudioOpus.java:91-93
if (encodedBytesCnt < 0) {
    Log.e(TAG, "Encode error: " + encodedBytesCnt);
    _parentProtocolCallback.onProtocolTxError();
}
```

### 9.2 解码错误
```java
// AudioOpus.java:128-131
if (decodedSamplesCnt < 0) {
    Log.e(TAG, "Decode error: " + decodedSamplesCnt);
    _parentProtocolCallback.onProtocolRxError();
}
```

### 9.3 帧大小错误
```java
// AudioCodec2FrameAggregator.java:114-117
if (audioFrames.length % _codec2FrameSize != 0) {
    Log.e(TAG, "Ignoring audio frame of wrong size: " + audioFrames.length);
    _parentProtocolCallback.onProtocolRxError();
}
```

## 10. 音频数据包性能优化

### 10.1 帧聚合优化
```java
// 默认最大聚合帧大小: 48字节
_outputBufferSize = Integer.parseInt(sharedPreferences.getString(
    PreferenceKeys.CODEC2_TX_FRAME_MAX_SIZE, "48"));
```

### 10.2 缓冲区大小优化
```java
// AudioOpus.java:49-50
_pcmFrameSize = (int)(SAMPLE_RATE / 1000 * pcmFrameDuration);
_audioBufferSize = 10*_pcmFrameSize;  // 10倍帧大小作为缓冲区
```

## 11. 音频数据包格式总结

### 11.1 支持的编码格式
- **Codec2**: 专为业余无线电优化的低比特率语音编码
- **Opus**: 通用音频编码，支持可变比特率

### 11.2 传输协议
- **AX.25**: 业余无线电数据链路协议
- **HDLC**: 高级数据链路控制协议
- **KISS**: 简单串行协议

### 11.3 关键特性
- **帧聚合**: 提高传输效率
- **错误处理**: 完善的错误检测和恢复机制
- **缓冲区管理**: 优化的内存使用
- **实时处理**: 低延迟音频传输

这个音频数据包格式设计支持两种主要的音频编码标准：Codec2（专为业余无线电优化）和Opus（通用音频编码），通过AX.25协议进行传输，确保了音频数据在业余无线电网络中的可靠传输。
