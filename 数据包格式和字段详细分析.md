# 📦 数据包格式和字段详细分析

## 1. 协议栈层次结构

```
应用层: APRS 数据 (位置报告、消息等)
    ↓
数据链路层: AX.25 协议
    ↓  
帧同步层: HDLC 协议
    ↓
传输层: KISS 协议
    ↓
物理层: USB/蓝牙/音频传输
```

## 2. KISS 协议数据包格式

### 2.1 KISS 帧结构
```
| FEND | CMD | DATA | FEND |
| 0xC0 | 0x00|  ... | 0xC0 |
```

**字段说明：**
- **FEND (0xC0)**: 帧开始/结束标志
- **CMD**: 命令字节 (端口号 + 命令类型)
- **DATA**: 数据载荷
- **转义处理**: 0xDB 0xDC 表示 0xC0，0xDB 0xDD 表示 0xDB

### 2.2 KISS 命令类型
```java
// Kiss.java:42-51
KISS_CMD_DATA = 0x00;           // 数据帧
KISS_CMD_TX_DELAY = 0x01;       // 发送延迟
KISS_CMD_P = 0x02;              // 持续性
KISS_CMD_SLOT_TIME = 0x03;      // 时隙时间
KISS_CMD_TX_TAIL = 0x04;         // 发送尾部
KISS_CMD_SET_HARDWARE = 0x06;    // 硬件设置
KISS_CMD_SIGNAL_REPORT = 0x07;   // 信号报告
KISS_CMD_REBOOT = 0x08;         // 重启
KISS_CMD_TELEMETRY = 0x09;      // 遥测数据
```

## 3. HDLC 协议数据包格式

### 3.1 HDLC 帧结构
```
| 前导码 | 标志 | 数据 | CRC | 标志 |
| 0x7E...| 0x7E | ... | 2字节| 0x7E |
```

**字段说明：**
- **前导码**: 多个 0x7E 字节，用于同步
- **标志 (0x7E)**: 帧开始/结束标志
- **数据**: 实际载荷数据
- **CRC**: 2字节循环冗余校验
- **位填充**: 防止数据中出现连续6个1

## 4. AX.25 协议数据包格式

### 4.1 AX.25 帧结构
```
| 目标地址 | 源地址 | 中继路径 | 控制 | PID | 数据 |
| 7字节   | 7字节  | 7字节×N | 1字节|1字节| 变长 |
```

### 4.2 AX.25 字段详解

**地址字段 (7字节):**
```java
// AX25Callsign.java:52-75
public void fromBinary(byte[] data) {
    // 前6字节: 呼号 (左移1位)
    for (int i = 0; i < data.length - 1; i++) {
        int d = (data[i] & 0xff) >>> 1;
        char c = (char)d;
        if (c == ' ') break;
        buffer.append(c);
    }
    
    // 第7字节: SSID + 标志位
    byte lastByte = data[data.length - 1];
    isLast = (lastByte & 0x01) == 1;        // 最后地址标志
    ssid = (lastByte >>> 1) & 0x0f;          // SSID (0-15)
}
```

**控制字段:**
```java
// AX25Packet.java:26-28
AX25CTRL_UI = 0x03;        // UI 帧
AX25PID_NO_LAYER3 = 0xf0;   // 无第3层协议
AX25PID_AUDIO = 0xf1;       // 音频数据
```

### 4.3 AX.25 数据包字段
```java
// AX25Packet.java:19-24
public String src;        // 源呼号
public String dst;        // 目标呼号  
public String digipath;   // 中继路径
public boolean isAudio;   // 是否为音频数据
public byte[] rawData;    // 原始数据
public boolean isValid;   // 数据包是否有效
```

## 5. APRS 协议数据包格式

### 5.1 APRS 数据类型
```java
// AprsDataType.java:5-17
public enum DataType {
    UNKNOWN,                                    // 未知类型
    MIC_E,                                      // Mic-E 位置报告
    MESSAGE,                                    // 文本消息
    POSITION_WITH_TIMESTAMP_MSG,               // 带时间戳的位置+消息
    POSITION_WITHOUT_TIMESTAMP_MSG,            // 无时间戳的位置+消息
    POSITION_WITH_TIMESTAMP_NO_MSG,            // 带时间戳的位置
    POSITION_WITHOUT_TIMESTAMP_NO_MSG,         // 无时间戳的位置
    OBJECT,                                     // 对象报告
    ITEM,                                       // 项目报告
    STATUS,                                     // 状态报告
    THIRD_PARTY                                 // 第三方数据
}
```

### 5.2 APRS 数据包标识符字段
```java
// AprsDataType.java:57-81
private DataType getDataTypeFromIdent(char ident) {
    if (ident == '`' || ident == '\'') {
        return DataType.MIC_E;                    // Mic-E 位置报告
    } else if (ident == ':') {
        return DataType.MESSAGE;                  // 文本消息
    } else if (ident == '=') {
        return DataType.POSITION_WITHOUT_TIMESTAMP_MSG;  // 位置报告(无时间戳+消息)
    } else if (ident == '!') {
        return DataType.POSITION_WITHOUT_TIMESTAMP_NO_MSG; // 位置报告(无时间戳)
    } else if (ident == '@') {
        return DataType.POSITION_WITH_TIMESTAMP_MSG;       // 位置报告(带时间戳+消息)
    } else if (ident == '/') {
        return DataType.POSITION_WITH_TIMESTAMP_NO_MSG;    // 位置报告(带时间戳)
    } else if (ident == ';') {
        return DataType.OBJECT;                   // 对象报告
    } else if (ident == ')') {
        return DataType.ITEM;                     // 项目报告
    } else if (ident == '>') {
        return DataType.STATUS;                   // 状态报告
    } else if (ident == '}') {
        return DataType.THIRD_PARTY;              // 第三方数据
    } else {
        return DataType.UNKNOWN;                 // 未知类型
    }
}
```

## 6. 位置报告数据包格式

### 6.1 压缩位置报告格式
```java
// AprsDataPositionReport.java:98-122
private byte[] generateCompressedInfo(Position position) {
    ByteBuffer buffer = ByteBuffer.allocate(256);
    buffer.put((byte)'=');                        // 标识符
    buffer.put(getCompressedNmeaCoordinate(position)); // 压缩坐标
    
    // 速度/方向或高度
    if (position.isSpeedBearingEnabled) {
        buffer.put((byte)(33 + (byte)(position.bearingDegrees / 4.0)));
        double compressedSpeed = MathTools.log(1.08, 1 + UnitTools.metersPerSecondToKnots(position.speedMetersPerSecond));
        buffer.put((byte)(33 + (byte)(compressedSpeed)));
        buffer.put((byte)'[');
    } else if (position.isAltitudeEnabled) {
        double compressedAltitude = MathTools.log(1.002, UnitTools.metersToFeet(position.altitudeMeters));
        buffer.put((byte)(33 + (byte)(compressedAltitude / 100)));
        buffer.put((byte)(33 + (byte)(compressedAltitude % 100)));
        buffer.put((byte)'S');
    } else {
        buffer.put(" sT".getBytes());
    }
    buffer.put(position.comment.getBytes(StandardCharsets.UTF_8));
    return binaryInfo;
}
```

### 6.2 非压缩位置报告格式
```java
// AprsDataPositionReport.java:124-144
private byte[] generateUncompressedInfo(Position position) {
    ByteBuffer buffer = ByteBuffer.allocate(256);
    buffer.put((byte)'=');                        // 标识符
    buffer.put(getUncompressedNmeaCoordinate(position).getBytes()); // NMEA坐标
    
    // 航向/速度
    if (position.isSpeedBearingEnabled) {
        buffer.put(String.format(Locale.US, "%03d/%03d",
                (int) position.bearingDegrees,
                UnitTools.metersPerSecondToKnots(position.speedMetersPerSecond)).getBytes());
    }
    
    // 高度
    if (position.isAltitudeEnabled && position.altitudeMeters >= 0) {
        buffer.put(String.format(Locale.US, "/A=%06d",
                UnitTools.metersToFeet(position.altitudeMeters)).getBytes());
    }
    buffer.put(position.comment.getBytes(StandardCharsets.UTF_8));
    return binaryInfo;
}
```

## 7. 文本消息数据包格式

### 7.1 文本消息结构
```java
// AprsDataTextMessage.java:115-119
public byte[] toBinary() {
    return (ackId > 0)
            ? String.format(Locale.US, ":%-9s:%s{%d", dstCallsign, textMessage, ackId).getBytes(StandardCharsets.UTF_8)
            : String.format(":%-9s:%s", dstCallsign, textMessage).getBytes(StandardCharsets.UTF_8);
}
```

**字段说明：**
- **标识符**: `:` (冒号)
- **目标呼号**: 9字节，右填充空格
- **分隔符**: `:`
- **消息内容**: 实际文本
- **确认ID**: `{数字}` (可选)

### 7.2 文本消息解析
```java
// AprsDataTextMessage.java:62-108
public void fromBinary(String srcCallsign, String dstCallsign, String digipath, byte[] infoData) {
    ByteBuffer buffer = ByteBuffer.wrap(infoData);
    
    // 目标呼号 (9字节)
    byte[] callsign = new byte[9];
    buffer.get(callsign);
    this.dstCallsign = new String(callsign).replaceAll("\\s+$", "");
    
    // 分隔符 ':'
    byte b = buffer.get();
    if (b != ':') return;
    
    // 消息内容
    byte[] message = new byte[buffer.remaining()];
    buffer.get(message);
    String stringMessage = new String(message, StandardCharsets.UTF_8);
    
    // 解析确认ID
    Pattern p = Pattern.compile("^(.+)[{](\\d+){1,5}$", Pattern.DOTALL);
    Matcher m = p.matcher(stringMessage);
    if (m.find()) {
        this.textMessage = m.group(1);
        String ackNumStr = m.group(2);
        if (ackNumStr != null)
            this.ackId = Integer.parseInt(ackNumStr);
    } else {
        this.textMessage = stringMessage;
    }
}
```

## 8. 特殊数据包格式

### 8.1 LoRa APRS 文本包
```java
// AX25Packet.java:33-46
// 前缀: 0x3C, 0xFF, 0x01
if (data.length > 3 && data[0] == (byte)0x3c && 
    data[1] == (byte)0xff && data[2] == (byte)0x01) {
    String rawText = new String(Arrays.copyOfRange(data, 3, data.length), 
                               StandardCharsets.ISO_8859_1);
    AprsIsData textPacket = AprsIsData.fromString(rawText);
}
```

### 8.2 信号报告包
```java
// Kiss.java:326-333
if (signalLevelRaw.length == SIGNAL_LEVEL_EVENT_SIZE) {
    short rssi = data.getShort();    // 接收信号强度
    short snr = data.getShort();     // 信噪比
    protocolCallback.onReceiveSignalLevel(rssi, snr);
}
```

## 9. 数据包处理流程

```
接收数据包
    ↓
KISS 协议解包 (FEND 检测)
    ↓  
HDLC 协议解包 (0x7E 检测)
    ↓
AX.25 协议解包 (地址解析)
    ↓
APRS 协议解包 (数据类型识别)
    ↓
音频解码 (Codec2/Opus)
    ↓
PCM 音频输出
```

## 10. 关键常量定义

```java
// 缓冲区大小
private static final int TRANSPORT_INPUT_BUFFER_SIZE = 1024;
private static final int FRAME_OUTPUT_BUFFER_SIZE = 1024;
private static final int RX_BUFFER_SIZE = 8192;

// 最大包大小
public static int MaximumSize = 512;        // AX.25 最大包大小
public static int MaximumRptCount = 7;     // 最大中继数量

// 呼号长度
public static int CallsignMaxSize = 7;     // AX.25 呼号最大长度
```

这个数据包格式设计支持多种协议栈，从底层的 HDLC 帧同步到上层的 APRS 应用数据，形成了一个完整的业余无线电通信协议体系。
