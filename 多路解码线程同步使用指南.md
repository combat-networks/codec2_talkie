# ğŸµ å¤šè·¯è§£ç çº¿ç¨‹åŒæ­¥ä½¿ç”¨æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æŒ‡å—è¯¦ç»†ä»‹ç»äº†å¦‚ä½•åœ¨Codec2 Talkieé¡¹ç›®ä¸­é›†æˆå’Œä½¿ç”¨å¤šè·¯è§£ç çº¿ç¨‹åŒæ­¥åŠŸèƒ½ï¼Œç¡®ä¿å¤šè·¯éŸ³é¢‘èƒ½å¤Ÿæ­£ç¡®è§£ç ã€æ··éŸ³å’Œè¾“å‡ºã€‚

## ğŸš€ å¿«é€Ÿå¼€å§‹

### 1. åŸºæœ¬é›†æˆæ­¥éª¤

#### 1.1 åˆå§‹åŒ–åŒæ­¥ç®¡ç†å™¨

```java
// åœ¨AppWorkerä¸­åˆå§‹åŒ–
public class AppWorker extends Thread {
    private AudioSyncManager audioSyncManager;
    private AudioMixer audioMixer;
    private AudioTrack systemAudioPlayer;
    
    @Override
    public void run() {
        android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_AUDIO);
        Looper.prepare();
        
        // åˆå§‹åŒ–åŒæ­¥ç®¡ç†å™¨
        initializeAudioSync();
        
        // åŸæœ‰é€»è¾‘...
        Looper.loop();
    }
    
    private void initializeAudioSync() {
        // åˆ›å»ºéŸ³é¢‘æ··éŸ³å™¨
        audioMixer = new AudioMixer();
        audioMixer.initialize();
        
        // åˆ›å»ºåŒæ­¥ç®¡ç†å™¨
        audioSyncManager = new AudioSyncManager();
        audioSyncManager.initialize();
        
        Log.i("AppWorker", "Audio sync initialized");
    }
}
```

#### 1.2 æ³¨å†ŒéŸ³é¢‘é€šé“

```java
// æ³¨å†Œå¤šè·¯éŸ³é¢‘é€šé“
public void registerAudioChannels() {
    // æ³¨å†Œé€šé“1 (Codec2)
    audioSyncManager.registerChannel("channel_1");
    audioMixer.addChannel("channel_1");
    
    // æ³¨å†Œé€šé“2 (Opus)
    audioSyncManager.registerChannel("channel_2");
    audioMixer.addChannel("channel_2");
    
    // è®¾ç½®é€šé“å¢ç›Š
    audioMixer.setChannelGain("channel_1", 1.0f);
    audioMixer.setChannelGain("channel_2", 0.8f);
}
```

### 2. å¤„ç†éŸ³é¢‘æ•°æ®

#### 2.1 æ¥æ”¶éŸ³é¢‘å¸§

```java
// åœ¨åè®®æ ˆæ¥æ”¶å¤„ç†ä¸­
public void onReceiveCompressedAudio(String src, String dst, byte[] audioEncodedFrame) {
    // ç¡®å®šé€šé“ID
    String channelId = determineChannelId(src, dst);
    
    // å¤„ç†éŸ³é¢‘å¸§åŒæ­¥
    audioSyncManager.processAudioFrame(channelId, audioEncodedFrame);
    
    // åŸæœ‰è§£ç é€»è¾‘...
    short[] decodedAudio = performDecode(audioEncodedFrame);
    
    // åˆ›å»ºéŸ³é¢‘å¸§
    AudioFrame audioFrame = new AudioFrame(channelId, decodedAudio, 
                                          System.currentTimeMillis(), 
                                          decodedAudio.length);
    
    // æ·»åŠ åˆ°æ··éŸ³å™¨
    audioMixer.addAudioFrame(channelId, audioFrame);
}
```

#### 2.2 æ··éŸ³è¾“å‡º

```java
// åœ¨å®šæ—¶å¤„ç†ä¸­
private void processAudioOutput() {
    // è·å–æ··éŸ³åçš„éŸ³é¢‘æ•°æ®
    short[] mixedAudio = audioMixer.getMixedAudio();
    
    if (mixedAudio != null && mixedAudio.length > 0) {
        // å†™å…¥AudioTrack
        int bytesWritten = systemAudioPlayer.write(mixedAudio, 0, mixedAudio.length);
        if (bytesWritten > 0) {
            Log.d("AppWorker", "Mixed audio output: " + bytesWritten + " bytes");
        }
    }
}
```

## ğŸ”§ é«˜çº§é…ç½®

### 1. åŒæ­¥å‚æ•°è°ƒæ•´

#### 1.1 æ—¶é—´åŒæ­¥é…ç½®

```java
// è‡ªå®šä¹‰æ—¶é—´åŒæ­¥å‚æ•°
public class CustomTimeSyncController extends TimeSyncController {
    private static final long CUSTOM_SYNC_INTERVAL_MS = 5;      // 5msåŒæ­¥é—´éš”
    private static final long CUSTOM_MAX_DRIFT_MS = 2;         // æœ€å¤§æ¼‚ç§»2ms
    
    @Override
    public void initializeSync() {
        // è‡ªå®šä¹‰åˆå§‹åŒ–é€»è¾‘
        super.initializeSync();
    }
}
```

#### 1.2 æ•°æ®åŒæ­¥é…ç½®

```java
// è‡ªå®šä¹‰æ•°æ®åŒæ­¥å‚æ•°
public class CustomDataSyncController extends DataSyncController {
    private static final int CUSTOM_BUFFER_SIZE = 2048;         // 2KBç¼“å†²åŒº
    private static final int CUSTOM_SYNC_TIMEOUT_MS = 50;      // 50msè¶…æ—¶
    
    @Override
    public void initializeDataSync() {
        // è‡ªå®šä¹‰åˆå§‹åŒ–é€»è¾‘
        super.initializeDataSync();
    }
}
```

### 2. æ€§èƒ½ä¼˜åŒ–

#### 2.1 å†…å­˜ç®¡ç†

```java
// ä½¿ç”¨å¯¹è±¡æ± å‡å°‘GCå‹åŠ›
public class AudioFramePool {
    private final Queue<AudioFrame> framePool = new ConcurrentLinkedQueue<>();
    private final int maxPoolSize = 100;
    
    public AudioFrame getFrame(String channelId, short[] audioData, long timestamp, int sampleCount) {
        AudioFrame frame = framePool.poll();
        if (frame == null) {
            return new AudioFrame(channelId, audioData, timestamp, sampleCount);
        }
        
        // é‡ç”¨ç°æœ‰å¸§
        return frame;
    }
    
    public void returnFrame(AudioFrame frame) {
        if (framePool.size() < maxPoolSize) {
            framePool.offer(frame);
        }
    }
}
```

#### 2.2 çº¿ç¨‹ä¼˜å…ˆçº§ä¼˜åŒ–

```java
// è®¾ç½®éŸ³é¢‘çº¿ç¨‹ä¼˜å…ˆçº§
public class AudioThreadManager {
    public static void setAudioThreadPriority(Thread thread) {
        android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_AUDIO);
    }
    
    public static void setHighThreadPriority(Thread thread) {
        android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_DISPLAY);
    }
}
```

### 3. é”™è¯¯å¤„ç†

#### 3.1 åŒæ­¥é”™è¯¯å¤„ç†

```java
// è‡ªå®šä¹‰é”™è¯¯å¤„ç†
public class AudioSyncErrorHandler {
    private static final int MAX_SYNC_ERRORS = 5;
    private final Map<String, Integer> channelErrorCounts = new ConcurrentHashMap<>();
    
    public boolean handleSyncError(String channelId, Exception error) {
        int errorCount = channelErrorCounts.merge(channelId, 1, Integer::sum);
        
        if (errorCount > MAX_SYNC_ERRORS) {
            Log.e("AudioSync", "Too many sync errors for channel " + channelId + ", disabling");
            return false; // ç¦ç”¨é€šé“
        }
        
        Log.w("AudioSync", "Sync error for channel " + channelId + ": " + error.getMessage());
        return true; // ç»§ç»­å¤„ç†
    }
}
```

#### 3.2 è‡ªåŠ¨æ¢å¤æœºåˆ¶

```java
// è‡ªåŠ¨æ¢å¤ç®¡ç†å™¨
public class AudioSyncRecoveryManager {
    private static final long RECOVERY_CHECK_INTERVAL_MS = 1000;
    private final Timer recoveryTimer;
    
    public void startRecoveryMonitoring() {
        recoveryTimer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                checkAndRecoverSync();
            }
        }, RECOVERY_CHECK_INTERVAL_MS, RECOVERY_CHECK_INTERVAL_MS);
    }
    
    private void checkAndRecoverSync() {
        // æ£€æŸ¥åŒæ­¥çŠ¶æ€å¹¶æ‰§è¡Œæ¢å¤æ“ä½œ
        Log.d("AudioSync", "Checking sync recovery status");
    }
}
```

## ğŸ“Š ç›‘æ§å’Œè°ƒè¯•

### 1. åŒæ­¥çŠ¶æ€ç›‘æ§

```java
// ç›‘æ§åŒæ­¥çŠ¶æ€
public void monitorSyncStatus() {
    // è·å–åŒæ­¥ç»Ÿè®¡ä¿¡æ¯
    AudioSyncManager.SyncStatistics syncStats = audioSyncManager.getSyncStatistics();
    
    // æ£€æŸ¥æ‰€æœ‰é€šé“æ˜¯å¦åŒæ­¥
    boolean allSynced = audioSyncManager.areAllChannelsSynced();
    
    // è·å–æ··éŸ³ç»Ÿè®¡ä¿¡æ¯
    AudioMixer.MixingStatistics mixingStats = audioMixer.getMixingStatistics();
    
    Log.i("AudioSync", "Sync status: " + syncStats);
    Log.i("AudioSync", "All channels synced: " + allSynced);
    Log.i("AudioSync", "Mixing stats: " + mixingStats);
}
```

### 2. æ€§èƒ½ç›‘æ§

```java
// æ€§èƒ½ç›‘æ§
public class AudioSyncPerformanceMonitor {
    private final Map<String, Long> channelLatencies = new ConcurrentHashMap<>();
    private final Map<String, Integer> channelDropCounts = new ConcurrentHashMap<>();
    
    public void recordChannelLatency(String channelId, long latency) {
        channelLatencies.put(channelId, latency);
    }
    
    public void recordChannelDrop(String channelId) {
        channelDropCounts.merge(channelId, 1, Integer::sum);
    }
    
    public void logPerformanceStats() {
        Log.i("AudioSync", "Channel latencies: " + channelLatencies);
        Log.i("AudioSync", "Channel drops: " + channelDropCounts);
    }
}
```

### 3. è°ƒè¯•å·¥å…·

```java
// è°ƒè¯•å·¥å…·ç±»
public class AudioSyncDebugger {
    public static void logSyncState(AudioSyncManager syncManager) {
        AudioSyncManager.SyncStatistics stats = syncManager.getSyncStatistics();
        
        Log.d("AudioSyncDebug", "=== Audio Sync State ===");
        Log.d("AudioSyncDebug", "Total channels: " + stats.channelCount);
        
        for (Map.Entry<String, AudioSyncManager.SyncStatistics.ChannelStats> entry : 
             stats.getChannelStats().entrySet()) {
            String channelId = entry.getKey();
            AudioSyncManager.SyncStatistics.ChannelStats channelStats = entry.getValue();
            
            Log.d("AudioSyncDebug", "Channel " + channelId + ": " +
                  "drift=" + channelStats.syncDrift + "ms, " +
                  "frames=" + channelStats.frameCount + ", " +
                  "errors=" + channelStats.errorCount);
        }
    }
}
```

## ğŸ¯ æœ€ä½³å®è·µ

### 1. é€šé“ç®¡ç†

```java
// é€šé“ç®¡ç†æœ€ä½³å®è·µ
public class ChannelManager {
    private final Map<String, ChannelInfo> channels = new ConcurrentHashMap<>();
    
    public boolean addChannel(String channelId, String codecType, float gain) {
        if (channels.containsKey(channelId)) {
            Log.w("ChannelManager", "Channel already exists: " + channelId);
            return false;
        }
        
        ChannelInfo info = new ChannelInfo(channelId, codecType, gain);
        channels.put(channelId, info);
        
        // æ³¨å†Œåˆ°åŒæ­¥ç®¡ç†å™¨
        audioSyncManager.registerChannel(channelId);
        audioMixer.addChannel(channelId);
        audioMixer.setChannelGain(channelId, gain);
        
        Log.i("ChannelManager", "Added channel: " + channelId);
        return true;
    }
    
    public boolean removeChannel(String channelId) {
        ChannelInfo info = channels.remove(channelId);
        if (info == null) {
            return false;
        }
        
        // ä»åŒæ­¥ç®¡ç†å™¨æ³¨é”€
        audioSyncManager.unregisterChannel(channelId);
        audioMixer.removeChannel(channelId);
        
        Log.i("ChannelManager", "Removed channel: " + channelId);
        return true;
    }
}
```

### 2. èµ„æºç®¡ç†

```java
// èµ„æºç®¡ç†æœ€ä½³å®è·µ
public class AudioSyncResourceManager {
    private final Set<String> activeChannels = new ConcurrentHashMap<String, Boolean>().keySet();
    
    public void cleanup() {
        // æ¸…ç†æ‰€æœ‰é€šé“
        for (String channelId : activeChannels) {
            audioSyncManager.unregisterChannel(channelId);
            audioMixer.removeChannel(channelId);
        }
        
        // å…³é—­åŒæ­¥ç®¡ç†å™¨
        audioSyncManager.shutdown();
        audioMixer.shutdown();
        
        Log.i("AudioSync", "Resource cleanup completed");
    }
}
```

### 3. å¼‚å¸¸å¤„ç†

```java
// å¼‚å¸¸å¤„ç†æœ€ä½³å®è·µ
public class AudioSyncExceptionHandler {
    public void handleException(String channelId, Exception e) {
        Log.e("AudioSync", "Exception in channel " + channelId, e);
        
        // æ ¹æ®å¼‚å¸¸ç±»å‹é‡‡å–ä¸åŒå¤„ç†ç­–ç•¥
        if (e instanceof OutOfMemoryError) {
            // å†…å­˜ä¸è¶³ï¼Œæ¸…ç†ç¼“å†²åŒº
            audioMixer.clearChannel(channelId);
        } else if (e instanceof InterruptedException) {
            // ä¸­æ–­å¼‚å¸¸ï¼Œæ¢å¤çº¿ç¨‹çŠ¶æ€
            Thread.currentThread().interrupt();
        } else {
            // å…¶ä»–å¼‚å¸¸ï¼Œè®°å½•å¹¶ç»§ç»­
            Log.w("AudioSync", "Unhandled exception type: " + e.getClass().getSimpleName());
        }
    }
}
```

## ğŸ”„ å®Œæ•´é›†æˆç¤ºä¾‹

```java
// å®Œæ•´çš„é›†æˆç¤ºä¾‹
public class MultiChannelAudioProcessor {
    private AudioSyncManager audioSyncManager;
    private AudioMixer audioMixer;
    private AudioTrack systemAudioPlayer;
    private Timer processTimer;
    
    public void initialize() {
        // åˆå§‹åŒ–æ··éŸ³å™¨
        audioMixer = new AudioMixer();
        audioMixer.initialize();
        
        // åˆå§‹åŒ–åŒæ­¥ç®¡ç†å™¨
        audioSyncManager = new AudioSyncManager();
        audioSyncManager.initialize();
        
        // åˆå§‹åŒ–AudioTrack
        initializeAudioTrack();
        
        // å¯åŠ¨å¤„ç†å®šæ—¶å™¨
        startProcessingTimer();
        
        Log.i("MultiChannelAudio", "Multi-channel audio processor initialized");
    }
    
    public void addChannel(String channelId, String codecType, float gain) {
        // æ³¨å†Œé€šé“
        audioSyncManager.registerChannel(channelId);
        audioMixer.addChannel(channelId);
        audioMixer.setChannelGain(channelId, gain);
        
        Log.i("MultiChannelAudio", "Added channel: " + channelId);
    }
    
    public void processAudioFrame(String channelId, byte[] encodedFrame) {
        // å¤„ç†éŸ³é¢‘å¸§
        audioSyncManager.processAudioFrame(channelId, encodedFrame);
        
        // è§£ç éŸ³é¢‘
        short[] decodedAudio = decodeAudio(encodedFrame);
        
        // åˆ›å»ºéŸ³é¢‘å¸§
        AudioFrame audioFrame = new AudioFrame(channelId, decodedAudio, 
                                            System.currentTimeMillis(), 
                                            decodedAudio.length);
        
        // æ·»åŠ åˆ°æ··éŸ³å™¨
        audioMixer.addAudioFrame(channelId, audioFrame);
    }
    
    private void startProcessingTimer() {
        processTimer = new Timer("AudioProcessTimer");
        processTimer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                processAudioOutput();
            }
        }, 10, 10); // 10msé—´éš”
    }
    
    private void processAudioOutput() {
        // è·å–æ··éŸ³åçš„éŸ³é¢‘æ•°æ®
        short[] mixedAudio = audioMixer.getMixedAudio();
        
        if (mixedAudio != null && mixedAudio.length > 0) {
            // å†™å…¥AudioTrack
            int bytesWritten = systemAudioPlayer.write(mixedAudio, 0, mixedAudio.length);
            if (bytesWritten > 0) {
                Log.d("MultiChannelAudio", "Mixed audio output: " + bytesWritten + " bytes");
            }
        }
    }
    
    public void shutdown() {
        // åœæ­¢å®šæ—¶å™¨
        if (processTimer != null) {
            processTimer.cancel();
        }
        
        // å…³é—­åŒæ­¥ç®¡ç†å™¨
        audioSyncManager.shutdown();
        audioMixer.shutdown();
        
        // åœæ­¢AudioTrack
        if (systemAudioPlayer != null) {
            systemAudioPlayer.stop();
            systemAudioPlayer.release();
        }
        
        Log.i("MultiChannelAudio", "Multi-channel audio processor shutdown");
    }
}
```

## ğŸ“ æ€»ç»“

æœ¬ä½¿ç”¨æŒ‡å—æä¾›äº†å®Œæ•´çš„å¤šè·¯è§£ç çº¿ç¨‹åŒæ­¥é›†æˆæ–¹æ¡ˆï¼ŒåŒ…æ‹¬ï¼š

1. **åŸºæœ¬é›†æˆ**: å¿«é€Ÿä¸Šæ‰‹çš„é›†æˆæ­¥éª¤
2. **é«˜çº§é…ç½®**: è‡ªå®šä¹‰å‚æ•°å’Œæ€§èƒ½ä¼˜åŒ–
3. **ç›‘æ§è°ƒè¯•**: çŠ¶æ€ç›‘æ§å’Œæ€§èƒ½åˆ†æ
4. **æœ€ä½³å®è·µ**: é€šé“ç®¡ç†ã€èµ„æºç®¡ç†å’Œå¼‚å¸¸å¤„ç†
5. **å®Œæ•´ç¤ºä¾‹**: ç«¯åˆ°ç«¯çš„é›†æˆç¤ºä¾‹

é€šè¿‡éµå¾ªæœ¬æŒ‡å—ï¼Œæ‚¨å¯ä»¥æˆåŠŸåœ°åœ¨Codec2 Talkieé¡¹ç›®ä¸­å®ç°å¤šè·¯éŸ³é¢‘çš„åŒæ­¥å¤„ç†ï¼Œç¡®ä¿éŸ³é¢‘è´¨é‡å’Œå®æ—¶æ€§ã€‚
